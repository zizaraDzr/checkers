/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _script1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./script1 */ \"./src/script1.js\");\n\r\nconsole.log(_script1__WEBPACK_IMPORTED_MODULE_0__.months)\r\nlet checkersArray = [] //в этой переменной будет массив из 32 шашек\r\nlet turn = true //если эта переменная true, то ходят белые, если false, то чёрные\r\nlet attackingFlag = false\r\nconst letterArray = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\r\nconst numberArray = ['1', '2', '3', '4', '5', '6', '7', '8']\r\nlet board = document.querySelector('.board')\r\nlet blackBlocks\r\nlet activeBlocks\r\n\r\nclass Checker {\r\n  constructor(coordinate) {\r\n    this.name = coordinate\r\n    this.queen = false\r\n    this.active = false\r\n    this.color = 0\r\n    this.attacked = false\r\n    this.attacking = false\r\n  }\r\n  //Метод, проверяющий, не становится ли шашка дамкой. Если занимает поля whiteQueens и blackQueens, то this.queen = true\r\n  checkIfQueen() {\r\n    let whiteQueens = ['B8', 'D8', 'F8', 'H8']\r\n    let blackQueens = ['A1', 'C1', 'E1', 'G1']\r\n    if (\r\n      this.classList.contains('white-checker') &&\r\n      !this.queen &&\r\n      whiteQueens.lastIndexOf(this.name) !== -1\r\n    ) {\r\n      return (this.queen = true)\r\n    }\r\n    if (\r\n      this.classList.contains('black-checker') &&\r\n      !this.queen &&\r\n      blackQueens.lastIndexOf(this.name) !== -1\r\n    ) {\r\n      return (this.queen = true)\r\n    }\r\n  }\r\n}\r\n//Отрисовка доски с присвоением клеткам (не шашкам) id (строка 50) через вспомогательный массив letterArray.\r\nfunction drawCheckers() {\r\n  let block\r\n  let flag = true\r\n\r\n  for (let i = 8; i > 0; i--) {\r\n    for (let j = 0; j < 8; j++) {\r\n      if (j == 0) flag = !flag\r\n      block = document.createElement('div')\r\n\r\n      if (flag) {\r\n        block.className = 'block black'\r\n        block.id = letterArray[j] + i\r\n      } else {\r\n        block.className = 'block white'\r\n      }\r\n\r\n      board.appendChild(block)\r\n      flag = !flag\r\n    }\r\n  }\r\n  //Расстановка шашек на доске и создание массива объектов шашек с присвоением значений свойства color, где 1 - белая шашка, 2 - чёрная шашка, 0 - пустая клетка.\r\n  blackBlocks = document.querySelectorAll('.black')\r\n  for (let blackBlock of blackBlocks) {\r\n    let checker = document.createElement('div')\r\n    if (+blackBlock.id[1] <= 3) {\r\n      checker.className = 'checker white-checker'\r\n\r\n      blackBlock.appendChild(checker)\r\n    } else if (+blackBlock.id[1] >= 6) {\r\n      checker.className = 'checker black-checker'\r\n      blackBlock.appendChild(checker)\r\n    } else {\r\n      blackBlock.appendChild(checker)\r\n      checker.className = ''\r\n    }\r\n    let NewChecker = new Checker(blackBlock.id)\r\n    if (checker.classList.contains('white-checker')) {\r\n      NewChecker.color = 1\r\n    } else if (checker.classList.contains('black-checker')) {\r\n      NewChecker.color = 2\r\n    } else {\r\n      NewChecker.color = 0\r\n    }\r\n    checkersArray.push(NewChecker)\r\n  }\r\n}\r\n\r\n//Отрисовка полей букв и цифр\r\nfunction drawSquareTitles() {\r\n  let horizontalTitle = document.querySelectorAll('.square-titles-horizontal')\r\n  let verticalTitle = document.querySelectorAll('.square-titles-vertical')\r\n  for (let letter of horizontalTitle) {\r\n    for (let i = 0; i < 8; i++) {\r\n      let createLetter = document.createElement('div')\r\n      createLetter.className = 'square-letter'\r\n      createLetter.textContent = letterArray[i]\r\n      letter.appendChild(createLetter)\r\n    }\r\n  }\r\n  for (let number of verticalTitle) {\r\n    for (let i = 1; i <= 8; i++) {\r\n      let createNumber = document.createElement('div')\r\n      createNumber.className = 'square-number'\r\n      createNumber.textContent = i\r\n      number.appendChild(createNumber)\r\n    }\r\n  }\r\n}\r\n\r\ndrawCheckers()\r\ndrawSquareTitles()\r\nmoveTransition(true)\r\nboard.addEventListener('click', clickChecker)\r\n\r\nfunction clearArrayOfSquares(squaresArray) {\r\n  let i = 0\r\n  while (i < squaresArray.length) {\r\n    if (squaresArray[i].length > 2 || Number.isNaN(squaresArray[i])) {\r\n      squaresArray.splice(i, 1)\r\n      // console.log(squaresArray[i]);\r\n    } else {\r\n      ++i\r\n    }\r\n  }\r\n  return squaresArray\r\n}\r\n\r\n//Проверку клеток вынес в отдельную функцию, которую вызываем в более сложных\r\nfunction checkSquares(checkerFromCheckerArray) {\r\n  let indexLetter = letterArray.indexOf(checkerFromCheckerArray.name[0])\r\n  let indexNumber = numberArray.indexOf(checkerFromCheckerArray.name[1])\r\n  // console.log(indexLetter);\r\n  // console.log(indexNumber);\r\n  //Составляем массив из четырёх клеток по диагонали\r\n  let squaresForCheck = [\r\n    letterArray[indexLetter + 1] + numberArray[indexNumber + 1],\r\n    letterArray[indexLetter - 1] + numberArray[indexNumber + 1],\r\n    letterArray[indexLetter - 1] + numberArray[indexNumber - 1],\r\n    letterArray[indexLetter + 1] + numberArray[indexNumber - 1],\r\n  ]\r\n  // console.log(checkedSquares);\r\n\r\n  //Удаление стрёмных элементов массива checkedSquares навроде 'Cundefined' и NaN, чтобы потом когда-либо не проводить проверок на них;\r\n  let checkedSquares = clearArrayOfSquares(squaresForCheck)\r\n  return checkedSquares\r\n}\r\n\r\n//Показ хода\r\nfunction showMoves(checker) {\r\n  for (let blackBlock of blackBlocks) {\r\n    blackBlock.classList.remove('active-block')\r\n  }\r\n  let currentChecker = checkersArray.find(\r\n    (o) => o.name === checker.parentElement.id\r\n  )\r\n  let checkedSquares = checkSquares(currentChecker)\r\n\r\n  for (let i = 0; i < checkedSquares.length; i++) {\r\n    let checkedSquare = checkersArray.find((o) => o.name === checkedSquares[i])\r\n    let square = document.querySelector(`#${checkedSquare.name}`)\r\n    //если шашка атакующая, то рядом с ней есть атакуемые, а значит подсвечиваются следующие клетки за атакуемой\r\n    if (currentChecker.attacking == true && checkedSquare.attacked == true) {\r\n      let squareForAttackMove = checkAttackPossibility(currentChecker, checkedSquare)\r\n      console.log(squareForAttackMove)\r\n      if (squareForAttackMove) {\r\n        square = document.querySelector(`#${squareForAttackMove}`)\r\n        square.classList.add('active-block')\r\n      }\r\n      \r\n    } else if (\r\n      checkedSquare.color === 0 &&\r\n      currentChecker.color !== 0 &&\r\n      currentChecker.attacking == false\r\n    ) {\r\n      //ограничение по ходу назад, черные могут ходить только в сторону уменьшения числа координаты клетки, белые только в сторону увеличения\r\n      if (\r\n        currentChecker.color == 1 &&\r\n        currentChecker.name[1] < checkedSquare.name[1]\r\n      )\r\n        square.classList.add('active-block')\r\n      else if (\r\n        currentChecker.color == 2 &&\r\n        currentChecker.name[1] > checkedSquare.name[1]\r\n      ) {\r\n        square.classList.add('active-block')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//функция, позволяющая продолжать пожирать шашки после первого пожирания, если это возможно, вызывается на строке 443, введена переменная attackingFlag для работы\r\nfunction continueToEat(checkerFromCheckerArray) {\r\n  let checkerFromCheckerArrayDiv = document.querySelector(\r\n    `#${checkerFromCheckerArray.name}`\r\n  ).firstElementChild\r\n  let possibleCheckersForTurn = document.querySelectorAll('.checker')\r\n  let checkedSquares = checkSquares(checkerFromCheckerArray)\r\n  for (let i = 0; i < checkedSquares.length; i++) {\r\n    let checkedSquare = checkersArray.find((o) => o.name === checkedSquares[i])\r\n    let squareForAttackMove = checkAttackPossibility(\r\n      checkerFromCheckerArray,\r\n      checkedSquare\r\n    )\r\n    if (!squareForAttackMove) continue\r\n    let square = document.querySelector(`#${squareForAttackMove}`)\r\n    square.classList.add('active-block')\r\n    checkerFromCheckerArray.attacking = true\r\n    checkerFromCheckerArray.active = true\r\n  }\r\n  if (checkerFromCheckerArray.attacking == true) {\r\n    for (let checker of possibleCheckersForTurn) {\r\n      checker.classList.remove('player-turn')\r\n    }\r\n    checkerFromCheckerArrayDiv.classList.add('player-turn')\r\n  } else {\r\n    attackingFlag = false\r\n  }\r\n}\r\n\r\n//Написал алгоритм на проверку возможности съесть шашку, добавил новые свойства шашкам attacked и attacking, если шашка атакует, то attacking - true, если атакована, то attacked - true\r\nfunction checkAttackPossibility(attackingChecker, attackedChecker) {\r\n  let squareToAttack = ''\r\n  let squareToAttackFirstSymbol\r\n  let squareToAttackSecondSymbol\r\n  // console.log(attackingChecker);\r\n  // console.log(attackedChecker);\r\n  if (\r\n    attackingChecker.color == attackedChecker.color ||\r\n    attackedChecker.color == 0 ||\r\n    !attackedChecker\r\n  ) {\r\n    return null\r\n  }\r\n  //суть алгоритма описал в тексте\r\n  let indexLetterAttacking = letterArray.indexOf(attackingChecker.name[0])\r\n  let indexLetterAttacked = letterArray.indexOf(attackedChecker.name[0])\r\n  let indexNumberAttacked = numberArray.indexOf(attackedChecker.name[1])\r\n  if (indexLetterAttacking > indexLetterAttacked) {\r\n    squareToAttackFirstSymbol = letterArray[indexLetterAttacked - 1]\r\n  } else {\r\n    squareToAttackFirstSymbol = letterArray[indexLetterAttacked + 1]\r\n  }\r\n  if (attackingChecker.name[1] > attackedChecker.name[1]) {\r\n    squareToAttackSecondSymbol = numberArray[indexNumberAttacked - 1]\r\n  } else {\r\n    squareToAttackSecondSymbol = numberArray[indexNumberAttacked + 1]\r\n  }\r\n  squareToAttack = squareToAttackFirstSymbol + squareToAttackSecondSymbol\r\n  // console.log(squareToAttack);\r\n  if (!squareToAttack) {\r\n    return null\r\n  }\r\n  let newPositionOfAttackingChecker = checkersArray.find(\r\n    (o) => o.name === squareToAttack\r\n  )\r\n  // console.log(newPositionOfAttackingChecker);\r\n  if (!newPositionOfAttackingChecker) {\r\n    return null\r\n  }\r\n  if (newPositionOfAttackingChecker.color == 0) {\r\n    attackedChecker.attacked = true\r\n    // console.log(attackedChecker);\r\n    return squareToAttack\r\n  }\r\n}\r\n\r\n//Сделать ход\r\nfunction makeMove(activeBlackBlock) {\r\n  let movedChecker = checkersArray.find((o) => o.active === true) //ищем активную шашку со свойством active = true, которая всегда только одна;\r\n\r\n  // console.log(movedChecker);\r\n\r\n  let newChecker = checkersArray.find((o) => o.name === activeBlackBlock.id) //это будущая шашка, которая появится на подсвеченном блоке\r\n\r\n  // console.log(newChecker);\r\n\r\n  let removedCheckerDiv = document.querySelector(\r\n    `#${movedChecker.name}`\r\n  ).firstElementChild // сам div-шашка\r\n\r\n  // console.log(removedCheckerDiv);\r\n\r\n  //Манипуляция с классами контейнеров и переписывание свойств вовлечённых в ход объектов из массива\r\n  if (movedChecker.color === 1) {\r\n    activeBlackBlock.firstElementChild.classList.add(\r\n      'checker',\r\n      'white-checker',\r\n      'active-checker'\r\n    )\r\n    newChecker.color = 1\r\n  }\r\n  if (movedChecker.color === 2) {\r\n    activeBlackBlock.firstElementChild.classList.add(\r\n      'checker',\r\n      'black-checker',\r\n      'active-checker'\r\n    )\r\n    newChecker.color = 2\r\n  }\r\n  //Удаление съедаемой шашки\r\n  if (movedChecker.attacking == true) {\r\n    let indexLetterMovedChecker = letterArray.indexOf(movedChecker.name[0])\r\n    let indexLetterNewChecker = letterArray.indexOf(newChecker.name[0])\r\n    let eatenCheckerNameLetter =\r\n      letterArray[(indexLetterMovedChecker + indexLetterNewChecker) / 2]\r\n    let eatenCheckerNameNumber =\r\n      (+movedChecker.name[1] + +newChecker.name[1]) / 2\r\n    let eatenCheckerName = eatenCheckerNameLetter + eatenCheckerNameNumber\r\n    let eatenChecker = checkersArray.find((o) => o.name == eatenCheckerName)\r\n    // console.log(\"съедаемая шашкa\", eatenChecker);\r\n    let eatenCheckerDiv = document.querySelector(\r\n      `#${eatenCheckerName}`\r\n    ).firstElementChild\r\n    eatenChecker.color = 0\r\n    eatenCheckerDiv.className = ''\r\n    attackingFlag = true\r\n  }\r\n  removedCheckerDiv.className = ''\r\n  movedChecker.color = 0\r\n  checkersArray.forEach((item) => {\r\n    item.attacked = false\r\n    item.attacking = false\r\n    item.active = false\r\n  })\r\n  for (let blackBlock of blackBlocks) {\r\n    blackBlock.classList.remove('active-block')\r\n  }\r\n  // console.log(checkersArray);\r\n  return newChecker\r\n}\r\n// переход хода\r\n\r\nfunction moveTransition(firstMove = false) {\r\n  let checkersDivCollection = document.querySelectorAll('.checker')\r\n  if (!firstMove) turn = !turn\r\n  let color = turn ? 'white' : 'black'\r\n  let colorCheck\r\n  if (color == 'white') {\r\n    colorCheck = 1\r\n  } else {\r\n    colorCheck = 2\r\n  }\r\n  // console.log(colorCheck);\r\n  for (let checker of checkersDivCollection) {\r\n    checker.classList.remove('player-turn')\r\n    checker.classList.remove('active-checker')\r\n    let currentChecker = checkersArray.find(\r\n      (o) => o.name === checker.parentElement.id\r\n    )\r\n    let squaresForMove = checkSquares(currentChecker)\r\n\r\n    for (let i = 0; i < squaresForMove.length; i++) {\r\n      let squareForMove = checkersArray.find(\r\n        (o) => o.name === squaresForMove[i]\r\n      )\r\n\r\n      //Здесь шашка проверяется на возможность съесть, если съесть можно, то присваивается шашке attacking = true, а потом на строке 310 получаем массив из attacking-шашек\r\n      let possibleAttack = checkAttackPossibility(currentChecker, squareForMove)\r\n      // console.log(possibleAttack);\r\n      if (possibleAttack && currentChecker.color == colorCheck) {\r\n        currentChecker.attacking = true\r\n      }\r\n      // console.log(squareForMove);\r\n      // console.log(squaresForMove);\r\n      // console.log(squareForMove);\r\n      if (\r\n        checker.classList.contains(`${color}-checker`) &&\r\n        squareForMove.color == 0\r\n      ) {\r\n        checker.classList.add('player-turn')\r\n      }\r\n    }\r\n  }\r\n  let attackingCheckersArray = checkersArray.filter(\r\n    (checker) => checker.attacking == true\r\n  )\r\n  // console.log(attackingCheckersArray);\r\n\r\n  //Подсвечиваются только шашки, которые могут съедать, работает пока почему-то с багами, пока не могу понять, что происходит, попробуй сам, там где-то свойства attacking и attacked плывут, скорее всего\r\n\r\n  if (attackingCheckersArray.length > 0) {\r\n    for (let checker of checkersDivCollection) {\r\n      // console.log(checker);\r\n      checker.classList.remove('player-turn')\r\n    }\r\n    for (let i = 0; i < attackingCheckersArray.length; i++) {\r\n      let attackingCheckerDiv = document.querySelector(\r\n        `#${attackingCheckersArray[i].name}`\r\n      )\r\n      if (\r\n        attackingCheckerDiv.firstElementChild.classList.contains(\r\n          `${color}-checker`\r\n        )\r\n      ) {\r\n        attackingCheckerDiv.firstElementChild.classList.add('player-turn')\r\n      }\r\n    }\r\n  }\r\n  console.log('функция перехода хода сработала')\r\n}\r\n\r\nfunction clickChecker (e) {\r\n  let clickedChecker = e.target\r\n  let isClickActiveBlock = clickedChecker.classList.contains('active-block')\r\n\r\n  // если ход другого игрока и клик мимо 'active-block' выходим из функции (return)\r\n  if (\r\n    !clickedChecker.classList.contains('player-turn') &&\r\n    !isClickActiveBlock\r\n  ) {\r\n    return\r\n  }\r\n  let checkersDivCollection = document.querySelectorAll('.checker')\r\n\r\n  //добавил оформление активной шашки, на которую кликнул\r\n  if (clickedChecker.classList.contains('checker')) {\r\n    for (let checker of checkersDivCollection) {\r\n      checker.classList.remove('active-checker')\r\n    }\r\n    clickedChecker.classList.add('active-checker')\r\n  }\r\n  let checkerColor\r\n  if (turn) {\r\n    checkerColor = 'white-checker'\r\n  } else {\r\n    checkerColor = 'black-checker'\r\n  }\r\n  if (clickedChecker.classList.contains(checkerColor)) {\r\n    checkersArray.forEach((item) => {\r\n      item.active = false\r\n    })\r\n    checkersArray.forEach((item) => {\r\n      if (item.name === clickedChecker.parentElement.id) {\r\n        item.active = true\r\n      }\r\n    })\r\n    showMoves(clickedChecker)\r\n  }\r\n  if (isClickActiveBlock) {\r\n    let movedChecker = makeMove(clickedChecker)\r\n    if (attackingFlag) {\r\n      continueToEat(movedChecker) //заново кликать на шашку каждый раз не нужно, она остаётся активной, пока множественное взятие не будет реализовано, надо кликать просто на подсвеченные блоки\r\n    }\r\n    // console.log(attackingFlag);\r\n    if (!attackingFlag) {\r\n      //пока attackingFlag не станет false, функция перехода хода не вызывается. attackingFlag изменяет свои значения на 214 и 314 строках\r\n      moveTransition()\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack://checkers/./src/index.js?");

/***/ }),

/***/ "./src/script1.js":
/*!************************!*\
  !*** ./src/script1.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"months\": () => (/* binding */ months)\n/* harmony export */ });\nlet months = ['Jan', 'Feb', 'Mar', 'Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n//# sourceURL=webpack://checkers/./src/script1.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;